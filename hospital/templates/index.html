<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Floating Lines Shader</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }

        #container {
            width: 100%;
            height: 100%;
            position: relative;
        }
    </style>
</head>

<body>
    <div id="container"></div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

        const vertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fragmentShader = `
            precision highp float;

            uniform float iTime;
            uniform vec3  iResolution;
            uniform float animationSpeed;

            uniform bool enableTop;
            uniform bool enableMiddle;
            uniform bool enableBottom;

            uniform int topLineCount;
            uniform int middleLineCount;
            uniform int bottomLineCount;

            uniform float topLineDistance;
            uniform float middleLineDistance;
            uniform float bottomLineDistance;

            uniform vec3 topWavePosition;
            uniform vec3 middleWavePosition;
            uniform vec3 bottomWavePosition;

            uniform vec2 iMouse;
            uniform bool interactive;
            uniform float bendRadius;
            uniform float bendStrength;
            uniform float bendInfluence;

            uniform bool parallax;
            uniform float parallaxStrength;
            uniform vec2 parallaxOffset;

            uniform vec3 lineGradient[8];
            uniform int lineGradientCount;

            const vec3 BLACK = vec3(0.0);
            const vec3 PINK  = vec3(233.0, 71.0, 245.0) / 255.0;
            const vec3 BLUE  = vec3(47.0,  75.0, 162.0) / 255.0;

            mat2 rotate(float r) {
                return mat2(cos(r), sin(r), -sin(r), cos(r));
            }

            vec3 background_color(vec2 uv) {
                vec3 col = vec3(0.0);
                float y = sin(uv.x - 0.2) * 0.3 - 0.1;
                float m = uv.y - y;
                col += mix(BLUE, BLACK, smoothstep(0.0, 1.0, abs(m)));
                col += mix(PINK, BLACK, smoothstep(0.0, 1.0, abs(m - 0.8)));
                return col * 0.5;
            }

            vec3 getLineColor(float t, vec3 baseColor) {
                if (lineGradientCount <= 0) return baseColor;
                if (lineGradientCount == 1) return lineGradient[0] * 0.5;
                
                float clampedT = clamp(t, 0.0, 0.9999);
                float scaled = clampedT * float(lineGradientCount - 1);
                int idx = int(floor(scaled));
                float f = fract(scaled);
                
                vec3 c1 = vec3(0.0);
                vec3 c2 = vec3(0.0);
                
                // Unrolling or manual indexing for GLSL compatibility
                for(int i=0; i<8; i++) {
                    if(i == idx) c1 = lineGradient[i];
                    if(i == idx + 1) c2 = lineGradient[i];
                }
                
                return mix(c1, c2, f) * 0.5;
            }

            float wave(vec2 uv, float offset, vec2 screenUv, vec2 mouseUv, bool shouldBend) {
                float time = iTime * animationSpeed;
                float x_offset   = offset;
                float x_movement = time * 0.1;
                float amp        = sin(offset + time * 0.2) * 0.3;
                float y          = sin(uv.x + x_offset + x_movement) * amp;

                if (shouldBend) {
                    vec2 d = screenUv - mouseUv;
                    float influence = exp(-dot(d, d) * bendRadius);
                    float bendOffset = (mouseUv.y - screenUv.y) * influence * bendStrength * bendInfluence;
                    y += bendOffset;
                }

                float m = uv.y - y;
                return 0.0175 / max(abs(m) + 0.01, 1e-3) + 0.01;
            }

            void main() {
                vec2 fragCoord = gl_FragCoord.xy;
                vec2 baseUv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;
                baseUv.y *= -1.0;
                
                if (parallax) {
                    baseUv += parallaxOffset;
                }

                vec3 col = vec3(0.0);
                vec3 b = lineGradientCount > 0 ? vec3(0.0) : background_color(baseUv);

                vec2 mouseUv = vec2(0.0);
                if (interactive) {
                    mouseUv = (2.0 * iMouse - iResolution.xy) / iResolution.y;
                    mouseUv.y *= -1.0;
                }
                
                if (enableBottom) {
                    for (int i = 0; i < 50; i++) {
                        if (i >= bottomLineCount) break;
                        float fi = float(i);
                        float t = fi / max(float(bottomLineCount - 1), 1.0);
                        vec3 lineCol = getLineColor(t, b);
                        float angle = bottomWavePosition.z * log(length(baseUv) + 1.0);
                        vec2 ruv = baseUv * rotate(angle);
                        col += lineCol * wave(ruv + vec2(bottomLineDistance * fi + bottomWavePosition.x, bottomWavePosition.y), 1.5 + 0.2 * fi, baseUv, mouseUv, interactive) * 0.2;
                    }
                }

                if (enableMiddle) {
                    for (int i = 0; i < 50; i++) {
                        if (i >= middleLineCount) break;
                        float fi = float(i);
                        float t = fi / max(float(middleLineCount - 1), 1.0);
                        vec3 lineCol = getLineColor(t, b);
                        float angle = middleWavePosition.z * log(length(baseUv) + 1.0);
                        vec2 ruv = baseUv * rotate(angle);
                        col += lineCol * wave(ruv + vec2(middleLineDistance * fi + middleWavePosition.x, middleWavePosition.y), 2.0 + 0.15 * fi, baseUv, mouseUv, interactive);
                    }
                }

                if (enableTop) {
                    for (int i = 0; i < 50; i++) {
                        if (i >= topLineCount) break;
                        float fi = float(i);
                        float t = fi / max(float(topLineCount - 1), 1.0);
                        vec3 lineCol = getLineColor(t, b);
                        float angle = topWavePosition.z * log(length(baseUv) + 1.0);
                        vec2 ruv = baseUv * rotate(angle);
                        ruv.x *= -1.0;
                        col += lineCol * wave(ruv + vec2(topLineDistance * fi + topWavePosition.x, topWavePosition.y), 1.0 + 0.2 * fi, baseUv, mouseUv, interactive) * 0.1;
                    }
                }

                gl_FragColor = vec4(col, 1.0);
            }
        `;

        const config = {
            linesGradient: [], // Example: ['#ff0000', '#00ff00']
            enabledWaves: ['top', 'middle', 'bottom'],
            lineCount: [6, 6, 6],
            lineDistance: [5, 5, 5],
            topWavePosition: { x: 10.0, y: 0.5, rotate: -0.4 },
            middleWavePosition: { x: 5.0, y: 0.0, rotate: 0.2 },
            bottomWavePosition: { x: 2.0, y: -0.7, rotate: 0.4 },
            animationSpeed: 1.0,
            interactive: true,
            bendRadius: 5.0,
            bendStrength: -0.5,
            mouseDamping: 0.05,
            parallax: true,
            parallaxStrength: 0.2
        };

        function hexToVec3(hex) {
            let value = hex.trim().replace('#', '');
            if (value.length === 3) value = value.split('').map(c => c + c).join('');
            const r = parseInt(value.slice(0, 2), 16) / 255;
            const g = parseInt(value.slice(2, 4), 16) / 255;
            const b = parseInt(value.slice(4, 6), 16) / 255;
            return new THREE.Vector3(r, g, b);
        }

        const container = document.getElementById('container');
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        const targetMouse = new THREE.Vector2(-1000, -1000);
        const currentMouse = new THREE.Vector2(-1000, -1000);
        let targetInfluence = 0;
        let currentInfluence = 0;
        const targetParallax = new THREE.Vector2(0, 0);
        const currentParallax = new THREE.Vector2(0, 0);

        const uniforms = {
            iTime: { value: 0 },
            iResolution: { value: new THREE.Vector3() },
            animationSpeed: { value: config.animationSpeed },
            enableTop: { value: config.enabledWaves.includes('top') },
            enableMiddle: { value: config.enabledWaves.includes('middle') },
            enableBottom: { value: config.enabledWaves.includes('bottom') },
            topLineCount: { value: config.lineCount[0] || 6 },
            middleLineCount: { value: config.lineCount[1] || 6 },
            bottomLineCount: { value: config.lineCount[2] || 6 },
            topLineDistance: { value: (config.lineDistance[0] || 5) * 0.01 },
            middleLineDistance: { value: (config.lineDistance[1] || 5) * 0.01 },
            bottomLineDistance: { value: (config.lineDistance[2] || 5) * 0.01 },
            topWavePosition: { value: new THREE.Vector3(config.topWavePosition.x, config.topWavePosition.y, config.topWavePosition.rotate) },
            middleWavePosition: { value: new THREE.Vector3(config.middleWavePosition.x, config.middleWavePosition.y, config.middleWavePosition.rotate) },
            bottomWavePosition: { value: new THREE.Vector3(config.bottomWavePosition.x, config.bottomWavePosition.y, config.bottomWavePosition.rotate) },
            iMouse: { value: new THREE.Vector2(-1000, -1000) },
            interactive: { value: config.interactive },
            bendRadius: { value: config.bendRadius },
            bendStrength: { value: config.bendStrength },
            bendInfluence: { value: 0 },
            parallax: { value: config.parallax },
            parallaxStrength: { value: config.parallaxStrength },
            parallaxOffset: { value: new THREE.Vector2(0, 0) },
            lineGradient: { value: Array.from({ length: 8 }, () => new THREE.Vector3(1, 1, 1)) },
            lineGradientCount: { value: 0 }
        };

        if (config.linesGradient.length > 0) {
            const stops = config.linesGradient.slice(0, 8);
            uniforms.lineGradientCount.value = stops.length;
            stops.forEach((hex, i) => {
                const vec = hexToVec3(hex);
                uniforms.lineGradient.value[i].copy(vec);
            });
        }

        const material = new THREE.ShaderMaterial({
            uniforms,
            vertexShader,
            fragmentShader
        });

        const mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
        scene.add(mesh);

        const clock = new THREE.Clock();

        function resize() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            renderer.setSize(w, h);
            uniforms.iResolution.value.set(renderer.domElement.width, renderer.domElement.height, 1);
        }

        window.addEventListener('resize', resize);
        resize();

        if (config.interactive) {
            window.addEventListener('pointermove', e => {
                targetMouse.set(e.clientX * window.devicePixelRatio, (window.innerHeight - e.clientY) * window.devicePixelRatio);
                targetInfluence = 1.0;
                if (config.parallax) {
                    targetParallax.set(((e.clientX - window.innerWidth / 2) / window.innerWidth) * config.parallaxStrength, -((e.clientY - window.innerHeight / 2) / window.innerHeight) * config.parallaxStrength);
                }
            });
            window.addEventListener('pointerleave', () => targetInfluence = 0);
        }

        function animate() {
            uniforms.iTime.value = clock.getElapsedTime();

            if (config.interactive) {
                currentMouse.lerp(targetMouse, config.mouseDamping);
                uniforms.iMouse.value.copy(currentMouse);
                currentInfluence += (targetInfluence - currentInfluence) * config.mouseDamping;
                uniforms.bendInfluence.value = currentInfluence;
            }

            if (config.parallax) {
                currentParallax.lerp(targetParallax, config.mouseDamping);
                uniforms.parallaxOffset.value.copy(currentParallax);
            }

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>

</html>